<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>EPUB.js Pagination Example</title>
    <script src="/src/index.bundle?platform=web&dev=true&minify=false"></script>

    <link rel="stylesheet" type="text/css" href="examples.css" />

    <style type="text/css">
      body {
        display: flex;
        -webkit-align-items: center;
        -webkit-justify-content: center;
      }

      #viewer {
        width: 90%;
        height: 100vh;
        box-shadow: 0 0 4px #ccc;
        padding: 10px 10px 0px 10px;
        margin: 0px auto;
        background: white;
      }

      @media only screen and (min-device-width: 320px) and (max-device-width: 667px) {
        #viewer {
          height: 96.5%;
        }
        #viewer iframe {
          /* pointer-events: none; */
        }
        .arrow {
          position: inherit;
          display: none;
        }
      }
    </style>
  </head>
  <body>
    <div id="viewer"></div>
    <div id="prev" class="arrow">‹</div>
    <div id="next" class="arrow">›</div>
    <script>
      // Load the opf
      var book = ePub('/fixtures/moby-dick/OPS/package.opf');
      var rendition = book.renderTo('viewer', {
        manager: 'continuous',
        flow: 'paginated',
        width: '100%',
        height: '100%',
        snap: true,
      });

      var displayed = rendition.display('chapter_001.xhtml');

      displayed.then(function (renderer) {
        // -- do stuff
      });

      const segmenterEn = new Intl.Segmenter('en', { granularity: 'word' });

      function highlightWord(contents, wordsToHighlight) {
        const wordsObject = {};
        wordsToHighlight.forEach((word) => {
          wordsObject[word.toLowerCase()] = true;
        });

        // Recursively scan DOM for text nodes
        // If a text node contains a word, wrap it in a span with a background color red.
        function scanTextNodes(node) {
          if (node.nodeType === Node.TEXT_NODE) {
            var text = node.textContent;

            // Split text into words (preserving separators)
            const iterator = segmenterEn.segment(text)[Symbol.iterator]();

            // Create a document fragment to hold the new content
            var fragment = document.createDocumentFragment();
            var currentTextBuffer = '';
            var hasMatch = false;

            // Process each part of the split text in a single loop
            for (const part of iterator) {
              var trimmedPart = part.segment.toLowerCase();

              // Check if this part matches any highlight word
              if (trimmedPart && wordsObject[trimmedPart]) {
                hasMatch = true;
                // First, add any accumulated text as a single text node
                if (currentTextBuffer) {
                  var textNode = document.createTextNode(currentTextBuffer);
                  fragment.appendChild(textNode);
                  currentTextBuffer = '';
                }

                // Create highlighted span for the match
                var span = document.createElement('span');
                span.style.backgroundColor = 'red';
                span.dataset.word = trimmedPart;
                span.textContent = part.segment;
                fragment.appendChild(span);
              } else {
                // Accumulate non-matching text
                currentTextBuffer += part.segment;
              }
            }

            // Only replace the node if there were matches
            if (hasMatch) {
              // Add any remaining accumulated text
              if (currentTextBuffer) {
                var textNode = document.createTextNode(currentTextBuffer);
                fragment.appendChild(textNode);
              }

              // Replace the original text node with the fragment
              if (fragment.childNodes.length > 0) {
                node.parentNode.replaceChild(fragment, node);
              }
            }
          } else if (node.nodeType === Node.ELEMENT_NODE) {
            // Recursively process child nodes
            var children = Array.from(node.childNodes);
            for (var i = 0; i < children.length; i++) {
              scanTextNodes(children[i]);
            }
          }
        }

        // Start scanning from the content root
        scanTextNodes(
          contents.document.body || contents.document.documentElement,
        );
      }

      rendition.hooks.content.register(function (contents) {
        var wordsToHighlight = ['the', 'circulation', 'but', 'tiger-lilies'];
        console.time('highlight');
        highlightWord(contents, wordsToHighlight);
        console.timeEnd('highlight');
        return contents;
      });

      // Navigation loaded
      book.loaded.navigation.then(function (toc) {
        // console.log(toc);
      });

      var next = document.getElementById('next');
      next.addEventListener(
        'click',
        function () {
          rendition.next();
        },
        false,
      );

      var prev = document.getElementById('prev');
      prev.addEventListener(
        'click',
        function () {
          rendition.prev();
        },
        false,
      );

      document.addEventListener(
        'keyup',
        function (e) {
          // Left Key
          if ((e.keyCode || e.which) == 37) {
            rendition.prev();
          }

          // Right Key
          if ((e.keyCode || e.which) == 39) {
            rendition.next();
          }
        },
        false,
      );

      // $(window).on( "swipeleft", function( event ) {
      //   rendition.next();
      // });
      //
      // $(window).on( "swiperight", function( event ) {
      //   rendition.prev();
      // });
    </script>
  </body>
</html>
